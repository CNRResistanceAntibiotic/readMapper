#!/usr/bin/python
import argparse
import os
import subprocess
import glob
import difflib
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.SeqFeature import SeqFeature
from Bio.SeqFeature import FeatureLocation
from Bio.Seq import Seq


def read_sample(samplefile):
    samplelist, sampledic = [], {}
    f = open(samplefile, 'r')
    for line in f:
        line = line.strip().split('\t')
        samplelist.append(line[0])
        sampledic[line[0]] = {'genus':line[1].split(' ')[0], 'species':line[1].split(' ')[1]}
    f.close()
    return samplelist, sampledic


def exist_files(files):
    check = True
    for filename in files:
        if os.path.exists(filename) == False:
            check = False
    return check


def run_sickle(sickle, inF, inR, output_dir, read_type, phred, q, l, g, n, x, force):
    # https://github.com/najoshi/sickle
    # sickle se -t sanger -q 30 -l 40 -x -n -g -f in.fastq -o tr.fastq.gz
    # sickle pe -t illumina -l 80 -q 20 -g -f in_F.fastq -r in_R.fastq -o tr_F.fastq.gz -p tr_R.fastq.gz -s tr_S.fastq.gz

    if os.path.exists(os.path.join(output_dir, 'sickle'))==False:
        cmd = 'mkdir -p %s' % os.path.join(output_dir, 'sickle')
        os.system(cmd)

    if read_type == 'se':
        trim_list = [os.path.join(output_dir, 'sickle','sk_s1_se.fastq.gz')]
        if exist_files(trim_list) != True or force == True:
            cmd = '%s se -t %s -q %s -l %s' % (sickle, phred, q, l)
            option = (' -g',' -x',' -n')
            for index, item in enumerate([g, x, n]):
                if item == 'True':
                    cmd = cmd + option[index]
            cmd = cmd + ' -f %s -o %s ' % (inF, trim_list[0])
            print '\nTrimming unpaired file %s with sickle...\n' % inF
            out_str = subprocess.check_output(cmd, shell=True)
            print out_str
        else:
            print '\nTrimming already done!\n'
    else:
        trim_list = [os.path.join(output_dir, 'sickle','sk_s1_pe.fastq.gz'), os.path.join(output_dir, 'sickle','sk_s2_pe.fastq.gz'),
                     os.path.join(output_dir, 'sickle','sk_s3_up.fastq.gz')]
        if exist_files(trim_list) != True or force == True:
            cmd = '%s pe -t %s -q %s -l %s' % (sickle, phred, q, l)
            option = (' -g',' -x',' -n')
            for index, item in enumerate([g, x, n]):
                if item == 'True':
                    cmd = cmd + option[index]
            cmd = cmd + ' -f %s -r %s -o %s -p %s -s %s' % (inF, inR, trim_list[0], trim_list[1], trim_list[2])
            print '\nTrimming paired-end files %s and %s with sickle...\n' % (inF, inR)
            out_str = subprocess.check_output(cmd, shell=True)
            print out_str
        else:
            print '\nTrimming already done!\n'
    return trim_list


def rename_contig(filename):
    records = []
    f = open(filename, 'r')
    for n, rec in enumerate(SeqIO.parse(f,'fasta')):
        if len(rec.seq) > 500:
            rec.id = 'ctg_%i' % (n+1)
            records.append(rec)
            #print rec.id, rec.seq
    f.close()
    f = open(filename, 'w')
    SeqIO.write(records, f, 'fasta')
    f.close()


def run_spades(spades, pefile1, pefile2, sfile, outdir, force):
    ass_dir = os.path.join(outdir, 'spades')

    if exist_files([os.path.join(ass_dir,'scaffolds.fasta')]) != True or force == True:
        cmd = '%s --careful' % spades
        if pefile1 != '' and pefile2 != '':
            cmd = cmd + ' -1 %s -2 %s' % (pefile1, pefile2)

        if sfile != '':
            cmd = cmd + ' --s1 %s' % sfile

        cmd = cmd + ' -o %s' % ass_dir
        print '\nAssembly with SPAdes in process...'
        out_str = subprocess.check_output(cmd, shell=True)
        print out_str
    else:
        print '\nAssembly already done!\n'
    rename_contig(os.path.join(ass_dir, 'scaffolds.fasta'))


def run_quast(quast, outDir, force):

    if exist_files([os.path.join(outDir,'quast')]) != True or force == True:
        cmd = '%s %s -o %s' % (quast, os.path.join(outDir, 'spades', 'scaffolds.fasta'), os.path.join(outDir, 'quast'))
        print '\nAssembly quality assesment with Quast in process...\n'
        out_str = subprocess.check_output(cmd, shell=True)
        print out_str
        cmd = 'rm -Rf'
        for item in ['corrected', 'K*', 'tmp', 'misc', 'mismatch*']:
            cmd = cmd + ' %s' % os.path.join(outDir, 'quast', item)
        os.system(cmd)
    else:
        print '\nQuality assessing already done!\n'

    '''cmd = 'reapr perfectmap assembly.fa short_1.fq short_2.fq 300 perfect; ' \
          'reapr smaltmap assembly.fa long_1.fq long_2.fq long_mapped.bam;' \
          'reapr pipeline assembly.fa long_mapped.bam outdir perfect'''


def run_prokka(prokka, fastaFile, sample, evalue, genus, species, hmms, force):

    outDir = os.path.join(os.path.dirname(os.path.dirname(fastaFile)), 'annotation')

    if exist_files([outDir]) != True or force == True:
        print '\nAnnotation of %s with prokka in %s as species %s %s...' % (sample, outDir, genus, species)
        if hmms != '':
            hmms = '--hmms %s' % hmms
        if genus != '':
            genus = '--usegenus --genus %s' % genus
        if species != '':
            species = '--species %s' % species
        if evalue != '':
            evalue = '--evalue %s' % evalue

        cmd = '%s --outdir %s --prefix %s --locustag %s --metagenome %s %s %s %s --strain %s %s --force ' %\
            (prokka, outDir, sample, sample, hmms, genus, species, evalue, sample, fastaFile)
        os.system('PATH=${PATH}:/usr/local/prokka-1.11/bin; ' + cmd)
        #print >> sys.stderr
        #cmd = 'cp %s %s' % (os.path.join(outDir, sample+'.gbf'), os.path.join(outDir, sample+'.gbk'))
        #os.system(cmd)
        print 'Annotation of %s done!\n' % fastaFile
    else:
        print '\nAnnotation already done for %s!\n' % sample


def read_sequence_file(filename):
    if os.path.splitext(filename)[1] in ['.gbk', '.gb', '.gbf']:
        format = 'genbank'
    elif os.path.splitext(filename)[1] == '.faa':
        format = 'fasta'
    else:
        print '\nUnknown file format: %s' % os.path.splitext(filename)[1]
        print 'Please use .gbk, .gbf, .gb or .faa extention\n'
        exit()

    rec_lst = []
    #print filename, format
    f = open(filename, 'r')
    for record in SeqIO.parse(f, format):
        rec_lst.append(record)
        #print record.id, record.description
    f.close()
    print "%i records from %s\n" % (len(rec_lst), filename)
    return rec_lst, format


def parse_rep(anDic, repFile):
    f = open(repFile, 'r')
    for n, line in enumerate(f):
        if n > 0:
            line = line.strip().split('\t')
            sample = line[0]
            ID = line[1].split('_')[0]
            depth = float(line[2])
            cov  = float(line[3])
            ident = float(line[4])
            seq = line[5]
            anDic[ID] = {'type': 'misc_feature', 'label':'CNR::%s' % ID,
                         'notes': 'Replicon incompatibility group marker; Sequencing depth: %.2f; '
                                 'Perc. Coverage: %.2f; Perc. Identity: %.2f' % (depth, cov, ident), 'seq':seq}
    f.close()
    return anDic


def parse_arm(anDic, armFile):
    fna_records = []
    f = open(armFile)
    for rec in SeqIO.parse(f, 'fasta'):
        fna_records.append(rec)
        ID    = rec.description.split(' func')[0].split('__')[-1]
        label = rec.description.split(' func')[0].split('__')[3]
        note  = 'func'+rec.description.split(' func')[1]
        type  = 'CDS'
        seq   = str(rec.seq)
        anDic[ID] = {'type':type, 'label':'CNR::%s' % label, 'notes':'Antibiotic resistance factor; '+ note, 'seq':seq}
    f.close()
    return anDic, fna_records


def wash_annot(span, rec):
    rmfeatures = []
    for index, rec_feature in enumerate(rec.features):
        if rec_feature.type == 'CDS':
            rec_span = range(rec_feature.location.start.position, rec_feature.location.end.position + 1)
            overlap = [x for x in rec_span if x in span]
            if len(overlap) / float(len(rec_span)) > 0.1 or len(overlap) / float(len(span)) > 0.1:
                rmfeatures.append(index)
    rmfeatures.reverse()
    for index in rmfeatures:
        del rec.features[index]
    return rec


def score_match(seq, rec_seq):
    scoreDic = {}
    for n, seq in enumerate([seq, str(Seq(seq).reverse_complement())]):
        if n == 0:
            strand = 1
        else:
            strand = -1
        for n in range(0, len(rec_seq)-len(seq)):
            frg = rec_seq[n:n+len(seq)]
            #best_match = difflib.get_close_matches(seq, [frg], 1, 0.90)[0]
            score = difflib.SequenceMatcher(None, seq, frg).ratio()
            if score > 0.90:
                scoreDic[score] = {'start':n, 'end':n+len(seq), 'strand':strand, 'seq':frg, 'score':score}
    if scoreDic != {}:
        score_list = scoreDic.keys()
        score_list.sort()
        best_score = scoreDic[score_list[-1]]
    else:
        best_score = ''
    return best_score


def edit_gbk(gbkFile, anDic, outDir, sample):
    sample = os.path.splitext(os.path.basename(gbkFile))[0]
    if os.path.exists(gbkFile) == True and anDic != {}:
        record_lst, format = read_sequence_file(gbkFile)
        no_exact_matches = []
        #print anDic.keys()
        for annot in anDic.keys():
            data = anDic[annot]
            seq  = data['seq']
            rev_seq = str(Seq(seq).reverse_complement())
            found = False
            for rec in record_lst:
                contig_name = rec.id
                rec_seq = str(rec.seq)
                if rec_seq.find(seq) != -1:
                    anDic[annot]['ctg'] = rec.id
                    start = rec_seq.find(seq)
                    end = start + len(seq)
                    strand = 1
                    try:
                        translation = Seq(seq).translate(table='Bacterial',cds=True)
                    except:
                        translation = ''
                    if translation == '':
                        feature = SeqFeature(FeatureLocation(start, end, strand=strand), strand=strand, type=data['type'])
                        feature.qualifiers['label'] =  data['label']
                        feature.qualifiers['notes'] =  data['notes']
                    else:
                        feature = SeqFeature(FeatureLocation(start, end, strand=strand), strand=strand, type=data['type'])
                        feature.qualifiers['label'] =  data['label']
                        feature.qualifiers['product'] = data['label']
                        feature.qualifiers['notes'] =  data['notes']
                        feature.qualifiers['transl_table'] = "11"
                        feature.qualifiers['codon_start'] = "1"
                        feature.qualifiers['translation'] = translation
                    found = True

                elif rec_seq.find(rev_seq) != -1:
                    anDic[annot]['ctg'] = rec.id
                    start = rec_seq.find(rev_seq)
                    end = start + len(seq)
                    strand = -1
                    try:
                        translation = Seq(seq).translate(table='Bacterial',cds=True)
                    except:
                        translation = ''
                    if translation == '':
                        feature = SeqFeature(FeatureLocation(start, end, strand=strand), strand=strand, type=data['type'],
                                             qualifiers={'label':data['label'],'notes':data['notes']})
                    else:
                        feature = SeqFeature(FeatureLocation(start, end, strand=strand), strand=strand, type=data['type'],
                                             qualifiers={'label':data['label'],'product':data['label'],'notes':data['notes'],
                                                         'transl_table':'11', 'codon_start':'1', 'translation':translation})
                    found = True

                if found == True:
                    #print 'found', annot
                    #print feature
                    span = range(start, end + 1)
                    if feature.type == 'CDS':
                        rec = wash_annot(span, rec)
                    rec.features.append(feature)
                    rec.features.sort(key=lambda x: x.location.start.position)
                    break

            if found == False:
                no_exact_matches.append(annot)


    print 'No match', no_exact_matches
    db = os.path.join(outDir, 'db.fa')
    f = open(db, 'w')
    SeqIO.write(record_lst, f, 'fasta')
    f.close()

    tg, bl, qr = '','',''
    for annot in no_exact_matches:
        data = anDic[annot]
        seq = data['seq']

        qr = os.path.join(outDir, 'qr.fa')
        qf = open(qr, 'w')
        SeqIO.write([SeqRecord(Seq(seq), id=annot, name=annot, description=annot)], qf, 'fasta')
        qf.close()

        bl = os.path.join(outDir, 'blast.csv')
        cmd = "/usr/local/bin/usearch61 -usearch_global %s -db %s -id 0.9 --strand both -blast6out %s" % (qr, db, bl)
        os.system(cmd)

        f = open(bl, 'r')
        for line in f:
            line = line.split('\t')
            #qr = line[0]
            tg = line[1]
            #ident    = float(line[2])
            qr_start = int(line[6])
            qr_end   = int(line[7])
            start = int(line[8])
            end   = int(line[9])
            strand = 1
            if qr_start > qr_end:
                strand = -1
            if start > end:
                start, end = end, start
                strand = -1
        f.close()

        try:
            if strand == 1:
                translation = Seq(seq).translate(table='Bacterial', cds=True)
            else:
                translation = Seq(seq).reverse_complement().translate(table='Bacterial', cds=True)
            type = 'CDS'
        except:
            translation = ''
            type = 'misc_feature'
        if translation == '':
            feature = SeqFeature(FeatureLocation(start, end, strand=strand), strand=strand, type=type,
                                 qualifiers={'label': data['label'] + ' Warning', 'notes': data['notes']})
        else:
            feature = SeqFeature(FeatureLocation(start, end, strand=strand), strand=strand, type=type,
                                 qualifiers={'label': data['label'] + ' Warning', 'product': data['label'] + ' Warning', 'notes': data['notes'],
                                             'transl_table': '11', 'codon_start': '1', 'translation': translation})
        for rec in record_lst:
            if rec.id == tg:
                #span = range(start, end + 1)
                #if feature.type == 'CDS':
                #    rec = wash_annot(span, rec)
                rec.features.append(feature)
                rec.features.sort(key=lambda x: x.location.start.position)
                #rec.seq = rec.seq[:start] + seq + rec.seq[end+1:]
                break
    if bl != '' or qr != '' or db != '':
        cmd = 'rm %s %s %s' % (bl, qr, db)
        os.system(cmd)

    for rec in record_lst:
        n = 1
        for feature in rec.features:
            if feature.type != 'gene':
                feature.qualifiers['locus_tag'] = 'L%s_%i' % (sample, n)
                n += 1

    #cmd = 'rm %s' % os.path.join(outDir, 'annotation', '*')
    #os.system(cmd)

    for rec in record_lst:
        outfile = os.path.join(outDir, 'annotation', '%s.gbk' % rec.id)
        outf = open(outfile, 'w')
        SeqIO.write([rec], outf, 'genbank')
        outf.close()

    gbkFile = os.path.join(outDir, '%s.gbk' % sample)
    f = open(gbkFile, 'w')
    SeqIO.write(record_lst, f, 'genbank')
    f.close()

    return gbkFile


def edit_fna(gbkFile, fna_records, armFile, sample):
    f = open(gbkFile, 'r')
    for rec in SeqIO.parse(f, 'genbank'):
        ctg = rec.id
        for feature in rec.features:
            if 'label' in feature.qualifiers.keys():
                if feature.qualifiers['label'][0].startswith('CNR::') and 'Antibiotic resistance factor;' in feature.qualifiers['notes'][0]:
                    name = [sample, ctg, feature.qualifiers['locus_tag'][0]]
                    dna_seq = str(rec.seq)[feature.location.start:feature.location.end]
                    if feature.location.strand == -1:
                        dna_seq = Seq(dna_seq).reverse_complement()
                    for fna_rec in fna_records:
                        if str(fna_rec.seq) == str(dna_seq):
                            fna_rec.id = '__'.join(name + fna_rec.description.split(' func:')[0].split('__')[-2:])
                            fna_rec.description = 'func:' + fna_rec.description.split(' func:')[1]
                            break
    f.close()
    f = open(armFile, 'w')
    SeqIO.write(fna_records, f, 'fasta')
    f.close()


def write_faa(armFile):
    with open(armFile, 'r') as f:
        records = []
        for rec in SeqIO.parse(f, 'fasta'):
            try:
                rec.seq = rec.seq.translate(table='Bacterial', cds=True)
                records.append(rec)
            except:
                x = 0

    outfile = os.path.splitext(armFile)[0] + '.faa'
    with open(outfile, 'w') as f:
        SeqIO.write(records, f, 'fasta')


def main(args):

    sampleFile = args.sampleFile
    sampleList, sampleDic = read_sample(sampleFile)
    fqDir = args.readsDir
    wkDir = os.path.abspath(args.wkDir)

    force = args.force

    for sample in sampleList:
        #PARSE fastq fastq.gz files
        print 'Sample name: %s' % sample
        fastqList = glob.glob(os.path.join(fqDir, '%s_*.fastq*' % sample))
        fastqList.sort()
        if len(fastqList) == 0:
            print 'No fastq or fastq.gz file for %s' % sample
            inF, inR = '','' 
            continue
        elif len(fastqList) == 1:
            inF = fastqList[0]
            inR = ''
        else:
            inF, inR = fastqList[0], fastqList[1]
        
        if inR == '' and inF != '':
            read_type = 'se'
        elif inR != '' and inF != '':
            read_type = 'pe'
        else:
            read_type = ''

        print 'Read files:', fastqList
        print 'Read type: %s' % read_type

        #PARSE OUTPUT DIRECTORY
        outDir = os.path.join(wkDir, sample)
        if not os.path.exists(outDir):
            cmd = 'mkdir %s' % outDir
            print '\nMake output directory: %s\n' % outDir
            out_str = subprocess.check_output(cmd, shell=True)
            print out_str
        print 'Output directory: %s' % outDir

        #SICKLE FOR READ TRIMMING
        notrim = args.notrim
        if notrim == False:
            phred = args.phred
            q = args.sickle_q
            l = args.sickle_l
            g = args.sickle_g
            n = args.sickle_n
            x = args.sickle_x
            sickle = args.sickle
            trim_files = run_sickle(sickle, inF, inR, outDir, read_type, phred, q, l, g, n, x, force)
        else:
            trim_files = [inF, inR, '']

        #SPADES FOR ASSEMBLY
        spades = args.spades
        if len(trim_files) == 1:
            pefile1, pefile2, sfile = '', '', trim_files[0]
        else:
            pefile1, pefile2, sfile = trim_files[0], trim_files[1], trim_files[2]

        run_spades(spades, pefile1, pefile2, sfile, outDir, force)
        
        #QUAST FOR ASSEMBLY QUALITY
        quast = args.quast
        run_quast(quast, outDir, force)

        #ANNOTATION
        fastaFile = os.path.join(outDir, 'spades', 'scaffolds.fasta')
        genus  = sampleDic[sample]['genus']
        species = sampleDic[sample]['species']
        evalue = args.evalue
        prokka = args.prokka
        hmms = args.hmms
        run_prokka(prokka, fastaFile, sample, evalue, genus, species, hmms, force)

        #MAKE ANNOTATION COMPLET FROM ARIBA
        if args.readmapper == True:
            gbkFile = os.path.join(outDir, 'annotation', '%s.gbk' % sample)
            anDic = {}
            try:
                repFile = glob.glob(os.path.join(outDir, 'results_repDB_*.csv'))[0]
            except:
                repFile = ''
            if repFile != '':
                anDic = parse_rep(anDic, repFile)

            try:
                armFile = glob.glob(os.path.join(outDir, 'results_armDB_*.fna'))[0]
            except:
                armFile = ''
            if armFile != '':
                anDic, fna_records = parse_arm(anDic, armFile)

            gbkFile = edit_gbk(gbkFile, anDic, outDir, sample)

            if armFile != '':
                edit_fna(gbkFile, fna_records, armFile, sample)
                write_faa(armFile)
                for ext in ['err','fsa','gff','sqn','tbl']:
                    filename = os.path.join(outDir, 'annotation', '%s.%s' % (sample,ext))
                    cmd = 'rm %s' % filename
                    os.system(cmd)


def version():
    return "0.0.1"

def run():
    parser = argparse.ArgumentParser(description='Sickle Trimming')
    #SAMPLE FILE
    parser.add_argument('-s', '--sampeFile', dest='sampleFile', action="store", help='csv sample file')
    #READS INPUT FILES
    parser.add_argument('-r', '--readsDir', dest='readsDir', action="store", help='Fastq or fastq.gz directory')
    #OUTPUT DIR
    parser.add_argument('-d', '--wkDir', dest='wkDir', action="store", help='Output directory')
    
    #TRIMMING WITH SICKLE
    parser.add_argument('-nT', dest='notrim', action="store_true", default=False, help='Force overwrite')
    parser.add_argument('--p', dest='phred', action="store", default='sanger', help='sickle option type [sanger]')
    parser.add_argument('--q', dest='sickle_q', action="store", default='30', help='sickle option quality [30]')
    parser.add_argument('--l', dest='sickle_l', action="store", default='40', help='sickle option lenght [40]')
    parser.add_argument('--g', dest='sickle_g', action="store_true", help='sickle option g')
    parser.add_argument('--n', dest='sickle_n', action="store_true", help='sickle option n')
    parser.add_argument('--x', dest='sickle_x', action="store_true", help='sickle option x')
    parser.add_argument('-sck','--sickle', dest="sickle", default="/usr/local/sickle/sickle", help="Sickle location (default: /usr/local/sickle/sickle)")

    
    #SPADES ASSEMBLY
    parser.add_argument('-spd', '--spades',  dest='spades', action='store', default='/usr/local/SPAdes-3.10.0/bin/spades.py', help="Python script location")
    parser.add_argument('-qst', '--quast',   dest='quast', action='store', default='/usr/local/quast-4.4/quast.py', help="Python script location")

    #PROKKA
    parser.add_argument('-e','--evalue', dest="evalue", default="1e-30", help="Prokka e value [1e-30]")
    parser.add_argument('-hmms','--hmms', dest="hmms", default="/usr/local/prokka-1.11/db/hmm/Resfams.hmm", help="hmms profil location (default: /usr/local/prokka-1.11/db/hmm/Resfams.hmm)")
    parser.add_argument('-prk','--prokka', dest="prokka", default="/usr/local/prokka-1.11/bin/prokka", help="Prokka location (default: /usr/local/prokka-1.11/bin/prokka)")

    #MAKE ANNOTATION COMPLETE FROM READMAPPER
    parser.add_argument('-nR', dest='readmapper', action="store_false", default=True, help='Don\'t add annotation from readmapper')

    #FORCE 
    parser.add_argument('-F', dest='force', action="store_true", default=False, help='Force overwrite')

    #VERSION
    parser.add_argument('-V', '--version', action='version', version='annotation-'+version(), help = "Prints version number")
    args = parser.parse_args()
    return args


if __name__ == "__main__":
    args = run()
    main(args)


